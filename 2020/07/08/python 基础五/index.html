<!DOCTYPE html><html lang="zh-cn,en,default"><head><meta charset="utf-8"><title>Python 基础五 | LEE BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="LEE, LEE BLOG, 金融数值计算, 概率, Python"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://chubbylee-math.github.io/2020/07/08/python%20%E5%9F%BA%E7%A1%80%E4%BA%94/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="LEE"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="LEE" type="application/atom+xml"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="LEE" alt="LEE"><img src="/img/logo.png" alt="LEE"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/img/6.jpg" alt="Python 基础五"></div><header class="post__info"><h1 class="post__title">Python 基础五</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/ChubbyLEE-Math" target="_blank" rel="noopener">LEE</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-07-08</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h1 id="捕捉异常、模块、包、文件基础错操作"><a href="#捕捉异常、模块、包、文件基础错操作" class="headerlink" title="捕捉异常、模块、包、文件基础错操作"></a>捕捉异常、模块、包、文件基础错操作</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1、捕捉异常点"><a href="#1、捕捉异常点" class="headerlink" title="1、捕捉异常点"></a>1、捕捉异常点</h3><p>一旦出错，还要一级一级上报，知道查到某个函数可以处理该错误（比如，给用户输出一个错误信息）。所以高级语言通常可以内置一套 try..expect..finally. .的错误处理机制，Python也不例外。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>,r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>,e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br><span class="line">-------------------------</span><br><span class="line">        <span class="keyword">try</span>...</span><br><span class="line">        <span class="keyword">except</span>: division by zero</span><br><span class="line">        <span class="keyword">finally</span>...</span><br><span class="line">        END</span><br></pre></td></tr></table></figure><p>当我们认为某些代码可能会出错时，就可以用 <code>try</code> 来运行这段代码，如果执行出错，则<strong>后续代码不会继续执行</strong> ，而是直接跳转至错误处理代码，及 <code>except</code> 语句块，执行完 <code>except</code> 后，如果有 <code>finally</code> 语句块，则执行<code>finally</code> 语句块，至此，执行完毕。</p><p>上面的代码在计算 <code>10/0</code> 时会产生一个除法运算错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">except</span>: division by zero</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>从输出可以看出，当发生错误时，后续语句 <code>print(&#39;result:&#39;,r)</code> 不会被执行，<code>except</code> 由于捕捉到 <code>ZeroDivisionError</code> ，因此被执行。最后，<code>fianlly</code> 语句被执行。</p><p>如果把 <code>0</code> 改成 <code>2</code> ，则执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>...</span><br><span class="line">result: <span class="number">5.0</span></span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>由于没有错误发生，所以 <code>except</code> 语句块不会被执行，但是 <code>finally</code> 如果有，则一定会被执行(可以没有<code>finally</code> 语句)。</p><p>错误应该有多种种类，如果发生了不同类型的错误，应该由不同的 <code>except</code> 语句块处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / int(<span class="string">'a'</span>)</span><br><span class="line">    print(<span class="string">'result:'</span>,r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'ValueError:'</span>,e)    </span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>,e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p><code>int()</code> 函数可能会抛出 <code>ValueError</code>，所以可以用一个<code>except</code> 来捕捉 <code>ValueError</code> ，用另一个 <code>except</code> 捕捉 <code>ZeroDivisionError</code>。</p><p>此外，如果没有错误发生，可以在 <code>except</code> 后面加一个 <code>else</code> ，当没有错误发生时，会自动执行 <code>else</code> 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / int(<span class="string">'a'</span>)</span><br><span class="line">    print(<span class="string">'result:'</span>,r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'ValueError:'</span>,e)    </span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>,e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'no error!'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p>Python 的错误其实也是 <code>class</code> ，所有的错误类型都 <strong>继承</strong> 自 <code>BaseException</code> ，所以在使用 <code>except</code> 时需要注意的是，它不但捕获该类型的错误，还把其子类都一网打尽，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    foo()</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'ValueError'</span>)</span><br><span class="line"><span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'UnicodeError'</span>)</span><br></pre></td></tr></table></figure><p>第二个 <code>except</code> 永远也捕获不到 <code>UnicodeError</code> ,因为 <code>UnicodeError</code> 是 <code>ValueError</code> 的子类，如果有，也是被第一个 <code>except</code> 捕获了。</p><p>Python 所有错误都从 <code>BaseException</code> 类派生的，常见的错误类型和继承关系：</p><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p><p>使用 <code>try...except</code> 捕获错误还有一个好处，就是可以跨越多层调用，比如函数 <code>main()</code> 调用 <code>foo()</code> ，<code>foo()</code> 调用 <code>bar()</code> , 结果 <code>bar()</code> 出错了，这时，只要 <code>main()</code> 捕获到了，就可以处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/int(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bars</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Errot:'</span>,e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'finally...'</span>)</span><br></pre></td></tr></table></figure><p>也就是说不需要在每一个可能出错的地方去捕获错误，只要在合适的层次无捕获就可以了，这样可以大大减少写 <code>try...except...finally</code> 的麻烦。</p><p><strong>python 所有的标准异常类：</strong></p><table><thead><tr><th align="left">异常名称</th><th>描述</th></tr></thead><tbody><tr><td align="left">BaseException</td><td>所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td>解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td>用户中断执行(通常是输入^C)</td></tr><tr><td align="left">Exception</td><td>常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td>迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td>生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">SystemExit</td><td>Python 解释器请求退出</td></tr><tr><td align="left">StandardError</td><td>所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td>所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td>浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td>数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td>除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td>断言语句失败</td></tr><tr><td align="left">AttributeError</td><td>对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td>没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td>操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td>输入/输出操作失败</td></tr><tr><td align="left">OSError</td><td>操作系统错误</td></tr><tr><td align="left">WindowsError</td><td>系统调用失败</td></tr><tr><td align="left">ImportError</td><td>导入模块/对象失败</td></tr><tr><td align="left">KeyboardInterrupt</td><td>用户中断执行(通常是输入^C)</td></tr><tr><td align="left">LookupError</td><td>无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td>序列中没有没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td>映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td>内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td>未声明/初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td>访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td>一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td>尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td>Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td>缩进错误</td></tr><tr><td align="left">TabError</td><td>Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td>一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td>对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td>传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td>Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td>Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td>Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td>Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td>警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td>关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td>关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td>旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td>关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td>可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td>可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td>用户代码生成的警告</td></tr></tbody></table><h3 id="2-模块"><a href="#2-模块" class="headerlink" title="2. 模块"></a>2. 模块</h3><p><strong>模块：</strong> 通俗理解一个 .py 文件就是一个模块，模块是管理功能代码的。</p><p><strong>内置模块：</strong> 就是 Python 自己内部自带的模块，如 time、random 等。</p><h4 id="2-1-自定义模块的使用"><a href="#2-1-自定义模块的使用" class="headerlink" title="2.1 自定义模块的使用"></a>2.1 自定义模块的使用</h4><p>注意：自定义模块名字和变量名定义很类似，都是由字母、数字、下划线组成，但是不能以数字开头。</p><p><strong>创建名为 first_model 的自定义模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">'f_num'</span>,<span class="string">'show'</span>]</span><br><span class="line"><span class="comment"># 指定 __all__表示 from 模块名 import * 只能使用指定的功能代码，而不是所有的功能代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">g_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'我是一个函数'</span>)</span><br><span class="line"><span class="comment"># 定义类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sge = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name,self.age)</span><br><span class="line"><span class="comment"># 解决导入的模块中方法没有调用就会执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    show()</span><br></pre></td></tr></table></figure><p><strong>使用自定义的模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 1. import 直接导入</span></span><br><span class="line"><span class="keyword">import</span> first_model </span><br><span class="line"><span class="comment"># 使用模块中的功能代码</span></span><br><span class="line">print(first_model.g_num)</span><br><span class="line">first_model.show()</span><br><span class="line">stu = first_model.Student(<span class="string">'李四'</span>,<span class="number">20</span>)</span><br><span class="line">stu.show_msg()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从first——model 这个模块导入 show 的方法</span></span><br><span class="line"><span class="keyword">from</span> first_model <span class="keyword">import</span> show </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给模块起别名(避免多个模块中有一样的名字)</span></span><br><span class="line"><span class="keyword">from</span> second_model <span class="keyword">import</span> show <span class="keyword">as</span> second_show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一个模块的多个方法</span></span><br><span class="line"><span class="keyword">from</span> first_model <span class="keyword">import</span> show,Student</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一个模块的多个方法</span></span><br><span class="line"><span class="keyword">from</span> first_model <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 <code>__name__</code> 查看模块名，执行哪个文件，哪个文件中的 <code>__name__</code>输出<code>__main__</code> ,其他导入的 <code>__name__</code> 结果就是模块名字。</p><blockquote><p>模块导入注意点：<br>1. 自定义的模块名不要和系统的模块名重名，<br>2. 导入的功能代码不要再当前模块定义否则使用不了导入模块的功能代码</p></blockquote><h3 id="3-包的介绍"><a href="#3-包的介绍" class="headerlink" title="3. 包的介绍"></a>3. 包的介绍</h3><p><strong>包：</strong> 通俗理解包就是一个文件夹，只不过文件夹里由一个 <strong>init.py</strong> 文件，包是管理模块的，模块是管理功能代码的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----import 导入包里的模块-----</span></span><br><span class="line"><span class="keyword">import</span> first_package.first</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----import 导入包里的模块设置别名-----</span></span><br><span class="line"><span class="keyword">import</span> first_package.first <span class="keyword">as</span> one</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----from 导入包名 import 模块名-----</span></span><br><span class="line"><span class="keyword">from</span> first_package <span class="keyword">import</span> second</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----from 包名.模块名 import 功能代码-----</span></span><br><span class="line"><span class="keyword">from</span> first_package.first <span class="keyword">import</span> show</span><br><span class="line"></span><br><span class="line"><span class="comment"># =====form 包名 import* ，默认不会导入包里面的所有模块，需要在init 文件里面使用 __all__ 去指定导入的模块</span></span><br><span class="line"><span class="keyword">from</span> first_packageckage <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p><code>__init__</code> 文件写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果外界使用 from 包名 import *  ，默认不会导入包里面的所有模块，需要使用 __all__指定 __all__ =['first','second']</span></span><br><span class="line"><span class="comment"># 从当前包导入对应模块</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> first</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> second</span><br></pre></td></tr></table></figure><h3 id="4-文件的基本操作"><a href="#4-文件的基本操作" class="headerlink" title="4. 文件的基本操作"></a>4. 文件的基本操作</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>要以读文件的模式打开一个文件对象，要使用Python 内置的 <code>open()</code> 函数，传入文件名和标识符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'r'</span>)</span><br></pre></td></tr></table></figure><p>标识符 ‘r’ 表示读， 这样，就成功地打开了一个文件。</p><p>如果文件打开成功，可以用<code>read()</code> 方法读取全部内容。Python 把内容读到内存，用一个<code>str</code> 对象表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'Hello,world'</span></span><br></pre></td></tr></table></figure><p><strong>最后一步</strong> 调用<code>close()</code> 方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>由于文件读写时可能产生 <code>IOError</code> ,一旦出错，后面的 <code>f.close()</code> 也就不会调用，所以，为了保证无论是否出错都能正确关闭文件，可以使用 <code>try...finally</code> 来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>但是每次这样写太麻烦，所以 Python 引入 <code>with</code> 语句来自动帮我我们调用 <code>close()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	print(f.read())</span><br></pre></td></tr></table></figure><p>调用 <code>read()</code> 会一次性读取文件的全部内容，如果文件很大，内存就爆了。保险起见，可以反复调用 <code>read(size)</code> 方法，每次最多读取size 个字节的内容。另外，<code>readline()</code> 可以每次读取一行内容，调用<code>readlines()</code> 一次读取所有内容并按行返回 <code>list</code> 。</p><p>如果文件很小，<code>read()</code> 一次读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code> 比较保险；如果是配置文件，调用 <code>readlines()</code> 最方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">	print(line.strip()) <span class="comment"># 把末尾的'/n' 删掉</span></span><br></pre></td></tr></table></figure><h4 id="文件的打开方式"><a href="#文件的打开方式" class="headerlink" title="文件的打开方式"></a>文件的打开方式</h4><table><thead><tr><th><strong>模式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>r</strong></td><td><strong>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</strong></td></tr><tr><td><strong>w</strong></td><td><strong>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</strong></td></tr><tr><td><strong>a</strong></td><td><strong>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td></tr><tr><td><strong>rb</strong></td><td><strong>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</strong></td></tr><tr><td><strong>wb</strong></td><td><strong>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</strong></td></tr><tr><td><strong>ab</strong></td><td><strong>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td></tr><tr><td><strong>r+</strong></td><td><strong>打开一个文件用于读写。文件指针将会放在文件的开头.</strong></td></tr><tr><td><strong>w+</strong></td><td><strong>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</strong></td></tr><tr><td><strong>a+</strong></td><td><strong>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</strong></td></tr><tr><td><strong>rb+</strong></td><td><strong>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</strong></td></tr><tr><td><strong>wb+</strong></td><td><strong>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</strong></td></tr><tr><td><strong>ab+</strong></td><td><strong>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</strong></td></tr></tbody></table><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>要读取非 UTF-8 编码的文本文件，需要给 <code>open()</code> 函数传入 <code>encoding</code> 参数，例如，读取GBK编码的文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f= open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'gbk'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br></pre></td></tr></table></figure><p>遇到编码不规范的文件，可能会遇到 <code>UnicodeDecodeError</code>，因为文本文件中可能夹杂了一些非法变法的字符。遇到这种情况，<code>open()</code> 函数还接受一个 <code>errors</code> 参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'gbk'</span>,errors=<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件一样，唯一区别是调用 <code>open()</code> 函数时，传入 表示符 <code>&#39;w&#39;</code> 或者 <code>&#39;wb&#39;</code> 表示写文本文件或者二进制文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'w'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hello,Woeld!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>可以反复使用 <code>write()</code> 来写入文件，但是必须要使用 <code>f.close()</code> 来关闭文件。当我们写如文件时，操作系统往往不会立马把数据写入磁盘，而是放到缓存里空闲时间再慢慢写入。只有调用 <code>close()</code> 方法时，操作系统才能保证包所有数据写入磁盘。所以还是可以利用 <code>with</code> 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/python/test.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(<span class="string">'Hello,world!'</span>)</span><br></pre></td></tr></table></figure><p>要写入特定编码文本文件，要给 <code>open()</code> 函数传入 <code>encoding</code> 参数，将字符串转换为指定编码</p><p><strong>注意：</strong> 以<code>&#39;w&#39;</code> 模式写入文件时，如果文件已经存在，会直接覆盖（相当于删掉后新写入一个文件）。可以传入 <code>&#39;a&#39;</code> 来追加 （append）模式写入。</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://ChubbyLEE-Math.github.io">LEE</a> 版权所有。如若转载，请注明出处：LEE（<a href="https://ChubbyLEE-Math.github.io/2020/07/08/python%20%E5%9F%BA%E7%A1%80%E4%BA%94/">https://ChubbyLEE-Math.github.io/2020/07/08/python%20%E5%9F%BA%E7%A1%80%E4%BA%94/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2020/07/07/python%20%E5%9F%BA%E7%A1%80%E5%9B%9B/" title="Python 基础四"><i class="iconfont icon-prev"></i>Python 基础四</a></div><div class="post__prev post__prev--right"><a href="/2020/07/09/hello-world%20copy/" title="Hello World">Hello World<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Python/">Python</a><span class="block-list-count">5</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/07/09/hello-world%20copy/" title="Hello World"><div class="item__cover"><img src="/img/7.jpg" alt="Hello World"></div><div class="item__info"><h3 class="item__title">Hello World</h3><span class="item__text">2020-07-09</span></div></a></li><li class="latest-post-item"><a href="/2020/07/08/python%20%E5%9F%BA%E7%A1%80%E4%BA%94/" title="Python 基础五"><div class="item__cover"><img src="/img/6.jpg" alt="Python 基础五"></div><div class="item__info"><h3 class="item__title">Python 基础五</h3><span class="item__text">2020-07-08</span></div></a></li><li class="latest-post-item"><a href="/2020/07/07/python%20%E5%9F%BA%E7%A1%80%E5%9B%9B/" title="Python 基础四"><div class="item__cover"><img src="/img/5.jpg" alt="Python 基础四"></div><div class="item__info"><h3 class="item__title">Python 基础四</h3><span class="item__text">2020-07-07</span></div></a></li><li class="latest-post-item"><a href="/2020/07/07/python%20%E5%9F%BA%E7%A1%80%E4%B8%89/" title="Python 基础三"><div class="item__cover"><img src="/img/4.jpg" alt="Python 基础三"></div><div class="item__info"><h3 class="item__title">Python 基础三</h3><span class="item__text">2020-07-07</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><ul class="footer__contact-info"><p class="contact-info__item">Anyone who has never made a mistake</p><p class="contact-info__item">has never tried anything new</p><p class="contact-info__item">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;—— Nikola Tesla</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Shanghai, China</span></li></ul></ul></div></div><div class="footer-top__item footer__image text-align:center"><img src="/img/me.png" alt="logo" title="LEE" alt="LEE" style="border-radius:40%"></div><div class="footer-top__item footer-top__item--2"><h3 class="item__title">ME</h3><div class="item__content"><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-geren5"></i> <span>LEE</span></li><li class="contact-info__item"><i class="iconfont icon-jiaoyu"></i> <span>Doctoral Student in Statistics</span></li><li class="contact-info__item"><i class="iconfont icon-school"></i> <span>School of Math, SUFE</span></li></ul></div></div><div class="footer-top__item footer-top__item--2"><h3 class="item__title">Interests</h3><div class="item__content"><ul class="footer__contact-info"><li class="contact-info__item"><em>♔</em> <span>&nbsp; Financial Numerical Calculation</span></li><li class="contact-info__item"><em>♕</em> <span>&nbsp; Stochastic Partial Differential Equation</span></li><li class="contact-info__item"><em>♘</em> <span>&nbsp; Data Analysis and Mining</span></li><li class="contact-info__item"><em>♖</em> <span>&nbsp; Maching Learning</span></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://blog.noodler.xyz/" title="Ju’s Blog" target="_blank">胖子</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2020 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>, author : <a href="https://github.com/ChubbyLEE-Math" target="_blank">LEE</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/ChubbyLEE-Math" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="https://weibo.com/u/7010279829/home?wvr=5" target="_blank" title="weibo"><i class="iconfont icon-weibo"></i></a></li><li class="social-network__item"><a href="https://www.zhihu.com/people/yi-wan-lu-dan-fan" target="_blank" title="zhihu"><i class="iconfont icon-zhihu"></i></a></li><li class="social-network__item"><a href="mailto:sinx@163.sufe.deu.cn" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Python基础"],gitalk=new Gitalk({clientID:"75ee6014d805e1edb6e8",clientSecret:"51b5a55b90593eb15d410fda25ea2552a035e423",repo:"comment",owner:"ChubbyLEE-Math",admin:["ChubbyLEE-Math"],labels:tags,id:new Date(1594197691798).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
            });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
                for (i=0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
                }
            });</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>